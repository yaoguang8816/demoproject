@startuml
title
<font color=red size=16>系统服务注册流程一</font>

endtitle

header
<font color=red>Warning:</font>
Do not use for commercial purposes.
endheader
'--------------------------------------------
participant ServiceManager as SM
participant ServiceManagerNative as SMN
participant BinderInternal as BI
participant android_util_Binder.cpp as auB
participant ProcessState as PS
participant BpBinder as BB
participant IPCThreadState as ITS
box kernel
participant binder as kb
end box


[->SM:addService(\n<color red>"gfxinfo",GraphicsBinder</color>)
note over SM
这里以GraphicsBinder为例,GraphicsBinder继承
自Binder, gfxinfo为service name,也就是在获取
service的时候用到的那个名称,
通过adb shell service list可以查看所有注册的service
end note
activate SM
SM->SM:getIServiceManager
activate SM
SM->BI:getContextObject
BI->auB:getContextObject
activate auB
auB->PS:self
activate PS
note over PS
单例模式,一个进程创建一个实例
如果是system_server进程第一次进来,
那么会创建一个ProcessState实例,
否则直接返回gProcess
end note
PS->PS:new ProcessState
activate PS
note over PS
ProcessState初始化,如下：
mDriverName="/dev/binder" binder驱动名字
mDriverFD binder设备描述符
mVMStart 内存映射起始地址
mMaxThreads=15 默认最大线程数
end note
PS->PS:open_driver
activate PS
PS-->kb:open
PS-->kb:ioctl\n//获取binder版本
PS-->kb:ioctl\n//设置最大线程
deactivate PS
PS-->kb:mVMStart=mmap
note over PS
映射一块虚拟地址空间用来接收transactions
BINDER_VM_SIZE:大小为1M-2pages
PROT_READ:只读
end note
deactivate PS
PS-->auB:return gProcess
deactivate PS
auB->PS:getContextObject(<color red> NULL</color>)
activate PS
PS->PS:getStrongProxyForHandle(<color red>0</color>)
note over PS
获取handle对应的servre的IBinder代理,
这里handle为0表示server为servicemanager
这里最终会根据handle创建一个BpBinder
实例作为handle对应server的代理,使用
BC_INCREFS命令与kernel交互,对handle
对应的server创建一个引用
end note
activate PS
PS->BB:create(<color red>handle</color>)
hnote over BB:handle 为0指向 servicemanager
activate BB
BB->BB:new BpBinder
activate BB
BB->ITS:incWeakHandle
ITS->kb:ioctl(BC_INCREFS)
ITS-->BB
deactivate BB
BB-->PS:return BpBinder
deactivate BB
deactivate PS
PS-->auB:return IBinder
deactivate PS
auB->auB:javaObjectForIBinder
activate auB
note over auB
javaObjectForIBinder的作用就是把native的
IBinder转换为Java的 <color red>IBinder</color>
end note
auB-->SM:return IBinder
deactivate auB
deactivate auB
SM->SMN:asInterface(<color red>IBinder</color>)
activate SMN
note over SMN
asInterface作用是把 <color red>IBinder</color> 转换为 <color red>IInterface</color>
这里会先检查当前进程有没有IBinder的实现，如果有则直接返回
如果没有，则构建ServiceManagerProxy对象并返回，
并使得ServiceManagerProxy的变量mRemote指向IBinder
end note
SMN-->SM:return ServiceManagerProxy
deactivate SMN
SM->SM:sServiceManager=<<color red>IInterface</color>>
deactivate SM
SM->SMN:ServiceManagerProxy.addService(\n<color red>"gfxinfo",GraphicsBinder</color>)
deactivate SM
activate SMN
SMN->SMN:Parcel data\ndata.writeXXX()\nParcel reply
SMN->BB:mRemote.transact(\n<color red>ADD_SERVICE_TRANSACTION,data,reply</color>)
deactivate SMN
activate BB
BB->ITS:transact(<color red>handle,...</color>)
deactivate BB
activate ITS
ITS->ITS:writeTransaction(\n<color red>BC_TRANSACTION,...</color>)
activate ITS
ITS->ITS:binder_transaction_data tr
hnote over ITS:根据传进来的data等构建tr
ITS->ITS:mOut.writeInt32(cmd)
ITS->ITS:mOut.write(&tr)
hnote over ITS:mOut为Parcel类型,扁平化写数据
ITS-->BB
deactivate ITS
deactivate ITS

ITS->ITS:joinThreadPool
activate ITS
ITS->ITS:getAndExecuteCommand
activate ITS
ITS->ITS:talkWithDriver
activate ITS
ITS->ITS:binder_write_read bwr\nbwr.write_size=mOut.dataSize\nbwr.write_buffer=mOut.data
hnote over ITS:使用mOut数据构建binder_write_read结构
ITS->kb:ioctl(BINDER_WRITE_READ)
deactivate ITS
deactivate ITS
deactivate ITS
kb->kb:binder_ioctl
activate kb
kb->kb:binder_thread_write
activate kb
kb->kb:binder_proc_transaction(\nbinder_transaction)
activate kb
kb->kb:binder_enqueue_thread\n_work_ilocked
activate kb
kb->kb:thread->todo
hnote over kb:<work available>
deactivate kb
kb->kb:binder_wakeup_thread_ilocked
activate kb
kb->kb:wake_up_interruptible(&thread_wait)
hnote over kb:唤醒等待队列
deactivate kb
deactivate kb

deactivate kb

right footer Generated by Yaoguang
@enduml