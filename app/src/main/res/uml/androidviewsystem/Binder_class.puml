@startuml

title
<font color=red size=16>Binder类图</font>

endtitle

header
<font color=red>Warning:</font>
Do not use for commercial purposes.
endheader
'-----------------------------------------------------------
interface IBinder {
    transact()
}
class Binder {
    onTransact()
}
Binder .up.|> IBinder
interface IInterface {
    IBinder asBinder()
}
IInterface -> IBinder
interface IWindowManager {
}
abstract IWindowManager.Stub {
    static IWindowManager asInterface(IBinder)
    @Override asBinder()//返回Binder类型
}
IWindowManager.Stub -up-|> Binder
abstract IWindowManager.Stub.Proxy {
    android.os.IBinder mRemote
    //WindowManagerService的代理，
    通过ServiceManager.getService获取，
    是IBinder的子类
    @Override asBinder()//返回IBinder类型
}
IWindowManager .up.|> IInterface
IWindowManager.Stub .up.|> IWindowManager
IWindowManager.Stub.Proxy .up.|> IWindowManager
class WindowManagerService {
}
WindowManagerService -up-|> IWindowManager.Stub
class WallpaperManagerService {
    IWindowManager mIWindowManager = \n  IWindowManager.Stub.asInterface()
}
WallpaperManagerService -left-> IWindowManager.Stub
note bottom of WallpaperManagerService
WallpaperManagerService与IWindowManager
的实现WindowManagerService在同一进程，所以
asInterface会指向Stub对象
end note
class PhoneWindow {
    IWindowManager sWindowManager = \n  IWindowManager.Stub.asInterface()
}
PhoneWindow -up-> IWindowManager.Stub.Proxy
note bottom of PhoneWindow
PhoneWindow与IWindowManager的实现
WindowManagerService不在同一进程，
所以asInterface会指向Proxy对象
end note
IWindowManager.Stub.Proxy .right. IWindowManager.Stub :Binder通信

legend left
总结：
1. Binder可以即用于进程间通信(如PhoneWindow),也可以用于进程内通信(如WallpaperManagerService)
2. server端需要继承实现Binder类,client可以通过ServiceManager获取server端的代理,代理为IBinder对象IBinder
的transact会通过Binder通信机制触发调用Binder的onTransact
3. 图中Stub和Proxy是aidl文件编译产生的,Stub继承了Binder代表server端
4. 静态方法asInterface负责把IBinder转换为IInterface(因为IWindowManager继承了IBinder实现了IInterface),
通过IInterface可以访问WMS
5. ServiceManager可以获取对应service的IBinder,可供asInterface使用
endlegend

right footer Generated by Yaoguang
@enduml